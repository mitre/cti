{
    "type": "attack-pattern",
    "id": "attack-pattern--837073a4-9060-4bb9-8675-2acc7ad91533",
    "created_by_ref": "identity--8641df51-0f59-4a4d-a300-7f11ca320ba2",
    "created": "2018-03-05T19:11:07.421Z",
    "modified": "2018-03-05T19:11:07.421Z",
    "name": "Subvert Code-signing Facilities",
    "description": "Because languages use code signing facilities to vouch for code's identity and to thus tie code to its assigned privileges within an environment, subverting this mechanism can be instrumental in an attacker escalating privilege.\nAny means of subverting the way that a virtual machine enforces code signing classifies for this style of attack. This pattern does not include circumstances through which a signing key has been stolen.",
    "external_references": [
        {
            "source_name": "capec",
            "url": "https://capec.mitre.org/data/definitions/68.html",
            "external_id": "CAPEC-68"
        },
        {
            "source_name": "cwe",
            "url": "http://cwe.mitre.org/data/definitions/325.html",
            "external_id": "CWE-325"
        },
        {
            "source_name": "cwe",
            "url": "http://cwe.mitre.org/data/definitions/328.html",
            "external_id": "CWE-328"
        }
    ],
    "object_marking_refs": [
        "marking-definition--127d62dd-9993-48ef-9ef1-a9c686da9914"
    ],
    "x_capec_abstraction": "Standard",
    "x_capec_example_instances": [
        "In old versions (prior to 3.0b4) of the Netscape web browser Attackers able to foist a malicious Applet into a client's browser could execute the \"Magic Coat\" attack. In this attack, the offending Applet would implement its own getSigners() method. This implementation would use the containing VM's APIs to acquire other Applet's signatures (by calling _their_ getSigners() method) and if any running Applet had privileged-enough signature, the malicious Applet would have inherited that privilege just be (metaphorically) donning the others' coats.",
        "Some (older) web browsers allowed scripting languages, such as JavaScript, to call signed Java code. In these circumstances, the browser's VM implementation would choose not to conduct stack inspection across language boundaries (from called signed Java to calling JavaScript) and would short-circuit \"true\" at the language boundary. Doing so meant that the VM would allow any (unprivileged) script to call privileged functions within signed code with impunity, causing them to fall prey to luring attacks.",
        "The ability to load unsigned code into the kernel of earlier versions of Vista and bypass integrity checking is an example of such subversion. In the proof-of-concept, it is possible to bypass the signature-checking mechanism Vista uses to load device drivers."
    ],
    "x_capec_likelihood_of_attack": "Low",
    "x_capec_prerequisites": [
        "A framework-based language that supports code signing (such as, and most commonly, Java or .NET)",
        "Deployed code that has been signed by its authoring vendor, or a partner.",
        "The attacker will, for most circumstances, also need to be able to place code in the victim container. This does not necessarily mean that they will have to subvert host-level security, except when explicitly indicated."
    ],
    "x_capec_skills_required": {
        "Subverting code signing is not a trivial activity. Most code signing and verification schemes are based on use of cryptography and the attacker needs to have an understand of these cryptographic operations in good detail. Additionally the attacker also needs to be aware of the way memory is assigned and accessed by the container since, often, the only way to subvert code signing would be to patch the code in memory.\nFinally, a knowledge of the platform specific mechanisms of signing and verifying code is a must.": "High"
    },
    "x_capec_typical_severity": "Very High",
    "x_resources_required": "The Attacker needs no special resources beyond the listed prerequisites in order to conduct this style of attack."
}