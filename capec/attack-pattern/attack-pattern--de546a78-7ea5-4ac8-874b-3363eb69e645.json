{
    "type": "attack-pattern",
    "id": "attack-pattern--de546a78-7ea5-4ac8-874b-3363eb69e645",
    "created_by_ref": "identity--d922e967-ff9b-4f27-97e6-2fc5f54aac51",
    "created": "2018-03-05T19:06:10.973Z",
    "modified": "2018-03-05T19:06:10.973Z",
    "name": "Web Services API Signature Forgery Leveraging Hash Function Extension Weakness",
    "description": "When web services require callees to authenticate, they sometimes issue a token / secret to the caller that the caller is to use to sign their web service calls. In one such scheme the caller when constructing a request would concatenate all of the parameters passed to the web service with the provided authentication token and then generate a hash of the concatenated string (e.g., MD5, SHA1, etc.). That hash then forms the signature that is passed to the web service which is used on the server side to verify the origin authenticity and integrity of the message. There is a practical attack against an authentication scheme of this nature that makes use of the hash function extension / padding weakness. Leveraging this weakness, an attacker, who does not know the secret token, is able to modify the parameters passed to the web service by generating their own call and still generate a legitimate signature hash. For instance, consider the message to be passed to the web service is M (this message includes the parameters passed to the web service concatenated with the secret token / key bytes). The message M is hashed and that hash is passed to the web service and is used for authentication. The attacker does not know M, but can see Hash (M) and Length (M). The attacker can then compute Hash (M || Padding (M) II M') for any M'. The attacker does not know the entire message M, specifically the attacker does not know the secret bytes, but that does not matter. The attacker is still able to sign their own message M' and make the called web service verify the integrity of the message without an error. Because of the iterative design of the hash function, it is possible, from only the hash of a message and its length, to compute the hash of longer messages that start with the initial message and include the padding required for the initial message to reach a multiple of 512 bits. It is important to note that the attack not limited to MD5 and will work just as well with another hash function like SHA1.",
    "external_references": [
        {
            "source_name": "capec",
            "url": "https://capec.mitre.org/data/definitions/461.html",
            "external_id": "CAPEC-461"
        },
        {
            "source_name": "cwe",
            "url": "http://cwe.mitre.org/data/definitions/328.html",
            "external_id": "CWE-328"
        },
        {
            "source_name": "cwe",
            "url": "http://cwe.mitre.org/data/definitions/290.html",
            "external_id": "CWE-290"
        }
    ],
    "object_marking_refs": [
        "marking-definition--068ab041-90bb-4e30-9394-d306c62765a6"
    ],
    "x_capec_abstraction": "Standard",
    "x_capec_prerequisites": [
        "Web services check the signature of the API calls\nAuthentication tokens / secrets are shared between the server and the legitimate client\nThe API call signature is generated by concatenating the parameter list with the shared secret and hashing the result.\nAn iterative hash function like MD5 and SHA1 is used.\nAn attacker is able to intercept or in some other way gain access to the information passed between the legitimate client and the server in order to retrieve the hash value and length of the original message.\nThe communication channel between the client and the server is not secured via channel security such as TLS"
    ],
    "x_capec_skills_required": {
        "Medium level of cryptography knowledge, specifically how iterative hash functions work. This is needed to select proper padding.": "Medium"
    },
    "x_capec_typical_severity": "High",
    "x_resources_required": "Access to a function to produce a hash (e.g., MD5, SHA1)\nTools that allow the attacker to intercept a message between the client and the server, specifically the hash that is the signature and the length of the original message concatenated with the secret bytes"
}