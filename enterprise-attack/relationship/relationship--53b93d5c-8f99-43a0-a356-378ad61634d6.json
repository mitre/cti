{
    "type": "bundle",
    "id": "bundle--76f0e296-34b8-4acf-8352-0e840dd7d05e",
    "spec_version": "2.0",
    "objects": [
        {
            "type": "relationship",
            "id": "relationship--53b93d5c-8f99-43a0-a356-378ad61634d6",
            "created": "2022-03-30T14:26:51.876Z",
            "created_by_ref": "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5",
            "revoked": false,
            "object_marking_refs": [
                "marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168"
            ],
            "modified": "2025-04-16T22:15:25.161Z",
            "description": "Monitor network traffic for WMI connections for potential use to remotely edit configuration, start services, or query files. When remote WMI requests are over RPC it connects to a DCOM interface within the RPC group <code>netsvcs</code>. To detect this activity, a sensor is needed at the network level that can decode RPC traffic or on the host where the communication can be detected more natively, such as\u00a0Event Tracing for Windows. Using wireshark/tshark decoders, the WMI interfaces can be extracted so that WMI activity over RPC can be detected. Although the description details how to detect remote WMI precisely, a decent estimate has been to look for the string RPCSS within the initial RPC connection on 135/tcp. It returns a superset of this activity, and will trigger on all DCOM-related services running within RPC, which is likely to also be activity that should be detected between hosts. More about RPCSS at :\u00a0rpcss_dcom_interfaces.html\n\nLook for instances of the WMI querying in network traffic, and find the cases where a process is launched immediately after a connection is seen. This essentially merges the request to start a remote process via WMI with the process execution. If other processes are spawned from wmiprvse.exe in this time frame, it is possible for race conditions to occur, and the wrong process may be merged. If this is the case, it may be useful to look deeper into the network traffic to see if the desired command can be extracted.\n\nAfter the WMI connection has been initialized, a process can be remotely launched using the command:\u00a0<code>wmic /node:\"<hostname>\" process call create \"<command line>\"</code>, which is detected in the third Detection Pseudocode. \n\nThis leaves artifacts at both a network (RPC) and process (command line) level. When <code>wmic.exe</code> (or the schtasks API) is used to remotely create processes, Windows uses RPC (135/tcp) to communicate with the the remote machine.\n\nAfter RPC authenticates, the RPC endpoint mapper opens a high port connection, through which the schtasks Remote Procedure Call is actually implemented. With the right packet decoders, or by looking for certain byte streams in raw data, these functions can be identified.\n\nWhen the command line is executed, it has the parent process of\u00a0<code>C:\\windows\\system32\\wbem\\WmiPrvSE.exe</code>. This analytic looks for these two events happening in sequence, so that the network connection and target process are output.\n\nCertain strings can be identifiers of the WMI by looking up the interface UUID for <code>IRemUnknown2</code> in different formats\n- UUID\u00a0<code>00000143-0000-0000-c000-000000000046</code>\u00a0(decoded)\n- Hex\u00a0<code>43 01 00 00 00 00 00 00 c0 00 00 00 00 00 00 46</code>\u00a0(raw)\n- ASCII\u00a0<code>CF</code>\u00a0(printable text only)\n\nThis identifier is present three times during the RPC request phase. Any sensor that has access to the byte code as raw, decoded, or ASCII could implement this analytic. The transfer syntax is\n- UUID\u00a0<code>8a885d04-1ceb-11c9-9fe8-08002b104860</code>\u00a0(decoded)\n- Hex\u00a0<code>04 5d 88 8a eb 1c c9 11 9f e8 08 00 2b 10 48 60</code>\u00a0(raw)\n- ASCII <code>`]+H``</code> (printable text only)\n\nThus, a great ASCII based signature is\n- <code>*CF*]+H*CF*CF*host*\"</code>\n\nNote: To detect WMI over RPC (using DCOM), a sensor needs to exist that has the insight into individual connections and can actually decode and make sense of RPC traffic. Specifically, WMI can be detected by looking at RPC traffic where the target interface matches that of WMI, which is IRemUnknown2. Look for instances of the WMI querying in network traffic, and find the cases where a process is launched immediately after a connection is seen. This essentially merges the request to start a remote process via WMI with the process execution. If other processes are spawned from\u00a0wmiprvse.exe in this time frame, it is possible for race conditions to occur, and the wrong process may be merged. If this is the case, it may be useful to look deeper into the network traffic to see if the desired command can be extracted.\n\nAnalytic 1 - Monitor for WMI over RPC (DCOM) connections. Look for the string RPCSS within the initial RPC connection on port 135/tcp.\n\n<code> index=windows_logs sourcetype=WinEventLog:Security OR sourcetype=WinEventLog:Microsoft-Windows-Sysmon/Operational OR sourcetype=WinEventLog:Microsoft-Windows-Security-Auditing\n| eval ProcessName=lower(ProcessName), CommandLine=lower(CommandLine)\n| search ProcessName IN (\"wmic.exe\", \"powershell.exe\", \"wmiprvse.exe\", \"wmiadap.exe\", \"scrcons.exe\", \"wbemtool.exe\")\n| search CommandLine IN (\"*process call create*\", \"*win32_process*\", \"*win32_service*\", \"*shadowcopy delete*\", \"*network*\")\n| search (sourcetype=\"WinEventLog:Security\" EventCode=4688) OR (sourcetype=\"WinEventLog:Microsoft-Windows-Sysmon/Operational\" EventCode=1)\n| join ProcessName [ search index=windows_logs sourcetype=WinEventLog:Microsoft-Windows-Sysmon/Operational EventCode=3 \n| eval DestinationIp = coalesce(DestinationIp, dest_ip)\n| eval DestinationPort = coalesce(DestinationPort, dest_port)\n| search DestinationPort IN (135, 5985, 5986) ]\n| stats count by _time, ComputerName, User, ProcessName, CommandLine, DestinationIp, DestinationPort, dest, src_ip, dest_ip\n| eval alert_message=\"Suspicious WMI Network Connection Detected: \" + ProcessName + \" executed by \" + User + \" on \" + ComputerName + \" with command: \" + CommandLine + \" connecting to \" + DestinationIp + \":\" + DestinationPort\n| where NOT (User=\"SYSTEM\" OR ProcessName=\"wmiprvse.exe\" OR (src_ip=\"trusted_ip_range\" AND DestinationIp=\"trusted_ip_range\"))\n| table _time, ComputerName, User, ProcessName, CommandLine, DestinationIp, DestinationPort, src_ip, dest_ip, alert_message</code>",
            "relationship_type": "detects",
            "source_ref": "x-mitre-data-component--181a9f8c-c780-4f1f-91a8-edb770e904ba",
            "target_ref": "attack-pattern--01a5a209-b94c-450b-b7f9-946497d91055",
            "x_mitre_modified_by_ref": "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5",
            "x_mitre_deprecated": false,
            "x_mitre_attack_spec_version": "3.2.0"
        }
    ]
}